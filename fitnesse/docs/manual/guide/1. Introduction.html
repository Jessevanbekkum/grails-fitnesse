<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>1. Introduction</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="1. Introduction">1. Introduction</a></h1>The Fitnesse plugin provides a integration point between the popular Open Source testing framework <a href="Fitnesse:http://www.fitnesse.org" target="blank"></a> and Grails applications.<p class="paragraph"/>This guide documents the usage of the plugin and provides an easy starting point to get you up to speed with the plugin as well as with Fitnesse.<p class="paragraph"/><blockquote class="note">
Note that the <strong class="bold">SLIM</strong> version of Fitnesse is supported. FIT, the older Fitnesse protocol, is not yet supported, nor will it be supported in the near future.
</blockquote><p class="paragraph"/><h4>Release History</h4>
<ul class="star">
<li>March 22, 2011</li>
<ul class="star">
<li>0.9 Release</li>
<ul class="star">
<li>We upped the version number to 0.9 because the plugin is quite feature complete now, and is almost stable enough to be a 1.0.</li>
<li>Feature: Introduced @Fixture annotation, so fixtures can now be given any name (they don't have to be suffixed with Fixture), as long as they are annotated with the annotation.</li>
<li>Feature: Added Transaction support</li>
<li>Bugfix: Fixed JSON conversion for domain classes and collections</li>
<li>Bugfix: Fixed reloading classes and fixtures that use inheritance</li>
<li>Bugfix: Fixed grails test-app</li>
<li>Bugfix: Fixed issues in the documentation</li>
</ul>
</ul>
<li>March 1, 2011</li>
<ul class="star">
<li>0.5 Release</li>
<ul class="star">
<li>Feature: Fitnesse testrunner created. Grails applications can now be tested using: grails test-app integration:fitnesse "FrontPage.GrailsTestSuite.SlimTestSystem?suite"</li>
<li>Feature: Fitnesse integrated. Fitnesse can now be started using: grails run-fitnesse</li>
<li>Feature: Fitnesse can be disabled by setting the grails.plugin.fitnesse.disabled property to true</li>
<li>Improvement: Internal Fitnesse upgraded to the newest Fitnesse version</li>
<li>Improvement: Naming of configuration parameters have changed to be more consistent. *Beware: the 'plugins' configuration option has changes to 'plugin' (without the 's')</li>
<li>Improvement: Bundled testproject in Github</li>
<li>Improvement: Fixture classes are now Spring beans</li>
<li>Bugfix: Fixed lazyloadingexception</li>
<li>Bugfix: Fixed exception message when a given constructor is not found for a fixture</li>
<li>Bugfix: Fixed reloading of services to give errors in Fixtures</li>
<li>Bugfix: Marcin's surname is fixed in the documentation!</li>
</ul>
</ul>
<li>November 16, 2010</li>
<ul class="star">
<li>0.4 Release, thanks to Marcin Erdmann!</li>
<ul class="star">
<li>Complete refactoring of the plugin thanks to Marcin Erdmann (ie using Artefacts, Artefact Templates, JSON Code to enable complex objects, and more!)</li>
<li><strong class="bold">Important</strong>: All fixtures should now be end with the suffix 'Fixture', as in 'CalculateFixture'. In the Wiki you can still refer to them as 'Calculate', but the plugin adds a Fixture suffix when looking for the class.</li>
<li>Improved error messages</li>
<li>You can now create complex objects from within Fitnesse by using JSON syntax.</li>
<li>More documentation!</li>
<li>Fixed some bugs in documentation (thanks Olivier Hedin for reporting!)</li>
</ul>
</ul>
<li>October 12, 2010</li>
<ul class="star">
<li>0.3 Release.</li>
<ul class="star">
<li>Added more documentation (configuration options, quickstart), refactored the internals</li>
<li>Added verbose logging switch</li>
<li>Fixed a Grails reloading bug, which caused ports to be opened twice. Now the plugin closes all ports, and reopens them whenever Grails forces a restart</li>
<li>You can now throw <a href="http://fitnesse.org/FitNesse.UserGuide.SliM.ExceptionHandling" target="blank">StopTest Exceptions</a> from Fixture constructors (which is not possible in the Java Fitnesse)</li>
</ul>
</ul>
<li>September 19, 2010</li>
<ul class="star">
<li>0.2 release. First public release. Includes lots of documentation, including a tutorial with 3 fixture types.</li>
</ul>
<li>September 15, 2010</li>
<ul class="star">
<li>initial 0.1 release.</li>
</ul></ul><p class="paragraph"/><h2><a name="1.1 Features">1.1 Features</a></h2>The Fitnesse plugin supports some additional features besides the standard Fitnesse functionality.<p class="paragraph"/><h3>Fixture annotation (since 0.9)</h3><p class="paragraph"/>Since version 0.9, it's possible to annotate Fixture classes with the @Fixture annotatation.
This means that fixtures can now be given any name (ie. they don't have to be suffixed with Fixture), as long as they are annotated with the @Fixture annotation.<p class="paragraph"/><div class="code"><pre>@Fixture
class BuyBook &#123;
    // contents here
&#125;</pre></div><p class="paragraph"/><h3>Transaction support (since 0.9)</h3><p class="paragraph"/>Transaction support provides three fixtures called BeginTransaction, Commit and Rollback. To use you need to import the fitnesse.grails package, i.e. in SetUp or SuiteSetUp:<p class="paragraph"/><div class="code"><pre>|<span class="java&#45;keyword">import</span>|
|fitnesse.grails|</pre></div><p class="paragraph"/>The transaction support was introduced mainly for scenarios where test pages via fixtures modify the database and you don't want that modifications to be persisted after the end of the test page execution. It means that the test page can be run multiple times without the need of cleaning up the database afterwards and it doesn't affect other tests by database contamination. To run a test page within a rolledback transaction simply add <code>begin transaction</code> and <code>rollback</code> tables to your test page:<p class="paragraph"/><div class="code"><pre>|begin transaction|<p class="paragraph"/>&#45;&#45;some test tables&#45;&#45;<p class="paragraph"/>|rollback|</pre></div><p class="paragraph"/>If you wish to run all of your test pages contained within a suite in rolledback transactions simply add begin transaction and rollback tables to SetUp and TearDown pages respectively for the given suite.<p class="paragraph"/><h3>Templates (since 0.4)</h3><p class="paragraph"/>You can now easily create Fixtures by typing:<p class="paragraph"/><div class="code"><pre>grails create&#45;fitnesse&#45;query&#45;fixture &#60;name of fixture&#62;</pre></div><p class="paragraph"/>Or<p class="paragraph"/><div class="code"><pre>grails create&#45;fitnesse&#45;fixture &#60;name of fixture&#62;</pre></div><p class="paragraph"/>This will create a fixture in the grails-app&#102;itnesse directory, which should give you a head start on how to create a Fixture.<p class="paragraph"/><h3>Complex objects (since 0.4)</h3><p class="paragraph"/>You can now create complex objects from within Fitnesse. This uses the JSON format, since it's easy to read and write, and is becoming quite a standard.<p class="paragraph"/>An example can be seen below:<p class="paragraph"/><strong class="bold">Wiki</strong>
<div class="code"><pre>|create book inventory                     |
|book                               |amount|
|&#123;author: Stephen King, title: IT&#125;  |     3|
|&#123;author: Dean Koontz, title: Chase&#125;|     5|</pre></div><p class="paragraph"/>This JSON code in the test is mapped to the following Fixture and Domain class:<p class="paragraph"/><strong class="bold">Fixture</strong>
<div class="code"><pre>class CreateBookInventoryFixture &#123;
    Book book<p class="paragraph"/>    <span class="java&#45;object">int</span> amount<p class="paragraph"/>    def bookService<p class="paragraph"/>    CreateBookInventoryFixture() &#123;
        Book.list()&#42;.delete()
    &#125;<p class="paragraph"/>    void execute() &#123;
        amount.times &#123;
            book.id = <span class="java&#45;keyword">null</span>
            bookService.addBook(book)
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>And the very simple Domain class:<p class="paragraph"/><div class="code"><pre>class Book &#123;
    <span class="java&#45;object">String</span> author
    <span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>Version 0.9 brings support for collections into JSON object conversion. The feature works for typed collection fixture fields but not for function parameters (because information about generics is is kept at runtime only for fields). It also works for hasMany relations in grails domain objects. Example usage is:<p class="paragraph"/><strong class="bold">Wiki</strong>
<div class="code"><pre>|json objects conversion with collections|
|producer|models|match?|
|&#123;name: 'Audi', models: &#91;&#123;name: 'A3'&#125;, &#123;name: 'A4'&#125;&#93;&#125;|&#91;&#123;name: 'A3'&#125;, &#123;name: 'A4'&#125;&#93;|<span class="java&#45;keyword">true</span>|</pre></div><p class="paragraph"/><strong class="bold">Fixture</strong>
<div class="code"><pre>class JsonObjectsConversionWithCollectionsFixture &#123;
    CarProducer producer<p class="paragraph"/>    List&#60;CarModel&#62; models<p class="paragraph"/>    <span class="java&#45;object">boolean</span> match() &#123;
        producer.models&#42;.name.containsAll(models&#42;.name)
    &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Domain classes</strong>
<div class="code"><pre>class CarProducer &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;models: CarModel&#93;
&#125;<p class="paragraph"/>class CarModel &#123;
    <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/><h3>Query Fixture DSL (since 0.4)</h3><p class="paragraph"/>To make writing Query fixtures much easier, we've introduced the concept of a simple mapping DSL. This means that mapping values from, let's say a services, becomes almost trivial.<p class="paragraph"/>Consider the following Service method:<p class="paragraph"/><div class="code"><pre>def checkInventory() &#123;
    Book.executeQuery(<span class="java&#45;quote">"select b.title, b.author, count(&#42;) from Book b group by title, author"</span>)
&#125;</pre></div><p class="paragraph"/>If you want to use this method in a Fixture, you can do by using the mapping DSL. An example can be shown below. Note that this only works for Query fixtures!<p class="paragraph"/><div class="code"><pre>class CheckBookInventoryFixture &#123;
    <span class="java&#45;keyword">static</span> queryFixture = <span class="java&#45;keyword">true</span>                              // indication that <span class="java&#45;keyword">this</span> is a query fixture
    <span class="java&#45;keyword">static</span> mapping   = &#91;title: 0, author: 1, amount: 2&#93;  // the mapping<p class="paragraph"/>    def bookService        // injected service<p class="paragraph"/>    def queryResults() &#123;  // queryResults() method, which must be named like <span class="java&#45;keyword">this</span>!
        bookService.checkInventory()
    &#125;
&#125;</pre></div><p class="paragraph"/>The mapping property determines how the query results will be mapped before being sent back to FitNesse. The keys of the map are column names from the FitNesse query table for the given fixture. The values might be indexes of columns returned by the implementation of queryResults method (i.e. if they are results from a executeQuery) or property names (i.e. if queryResults returns a collection of domain objects). The mapping property can also be a list of property names if property names of the result map one to one to table column names.<p class="paragraph"/>Since 0.9 you have to declare both queryFixture and mapping properties as static. It wasn't necessary before but the behaviour wasn't always consistent thus the support for non static properties was dropped.<p class="paragraph"/><h3>Strings as methods</h3>
Groovy supports methods like <code>"this is a method"</code>. The Fitnesse plugin also supports this, making some Fixtures more readable.<p class="paragraph"/><strong class="bold">Example</strong>
<div class="code"><pre>class MyFixture &#123;
  <span class="java&#45;object">boolean</span> <span class="java&#45;quote">"check <span class="java&#45;keyword">if</span> customers exists"</span>(<span class="java&#45;object">int</span> customerNumber) &#123;
     // &#8230;
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Default arguments</h4>
Groovy supports default arguments. The Grails Fitnesse plugin also supports this:<p class="paragraph"/><div class="code"><pre>class MyFixture &#123;
  MyFixture(<span class="java&#45;object">boolean</span> clearDatabase = <span class="java&#45;keyword">false</span>) &#123;
    // &#8230;
  &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Wiki:</strong>
<div class="code"><pre>|my fixture|<span class="java&#45;keyword">true</span>|</pre></div><p class="paragraph"/><h3>Untyped arguments</h3>
Groovy supports default arguments. Fitnesse also supports this:<p class="paragraph"/><div class="code"><pre>class MyFixture &#123;
  <span class="java&#45;object">boolean</span> checkCustomer(customerNumber) &#123;
    // &#8230;
  &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Note that the Fitnesse SLIM protocol only supports Strings and Lists. A result of this, is that when using untyped arguments, things could go wrong. An example of this is when using an integer.
This integer is interpreted as being a String, and hence it's converted to it's value, so int 1 becomes int 49. So, if you're unsure, use types in your fixtures.
</blockquote><p class="paragraph"/><h3>Automatic reloading of Fixtures</h3>
The Fixtures in the <code>grails-app/fitnesse</code> directory are automatically reloaded and injected by Grails. This enables faster testing and faster development!<p class="paragraph"/><h3>Functions are getters</h3>
Fitnesse decision tables do <strong class="bold">not</strong> have getters and setters, but setters and functions. A function is the same as a getter, but without the 'get' part. (Still with me?). An example:<p class="paragraph"/><strong class="bold">Normal Fitnesse</strong>
<div class="code"><pre>|my decision fixture|
|digit | roman?|
|1     |      I|
|5     |      V|</pre></div><p class="paragraph"/>This would result in the following Fixture:
<div class="code"><pre>class MyDecisionFixture &#123;
    <span class="java&#45;object">int</span> digit
    <span class="java&#45;object">String</span> roman<p class="paragraph"/>    void execute() &#123;
       roman = RomanNumberConverter.convertDigit(digit)
    &#125;<p class="paragraph"/>    <span class="java&#45;object">String</span> roman() &#123;
       <span class="java&#45;keyword">return</span> roman
    &#125;
&#125;</pre></div><p class="paragraph"/>This has been improved, so that Fitnesse also looks at getters:<p class="paragraph"/><strong class="bold">Improved Fitnesse</strong><p class="paragraph"/>This would result in the following Fixture:
<div class="code"><pre>class MyDecisionFixture &#123;
    <span class="java&#45;object">int</span> digit
    <span class="java&#45;object">String</span> roman<p class="paragraph"/>    void execute() &#123;
       roman = RomanNumberConverter.convertDigit(digit)
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>Improved Stop Test Exceptions</h3><p class="paragraph"/>You can now throw <a href="http://fitnesse.org/FitNesse.UserGuide.SliM.ExceptionHandling" target="blank">StopTest Exceptions</a> from Fixture constructors, to halt all further test execution.
This is currently not handled correctly in the Java version of Fitnesse.
    </body>
</html>
